Эта шпаргкалка содержит в себе информацию по тому, что проходилось на 8 и 9 занятиях 4 модуля. 8 занятие описывает работу от лица администратора, а 9 - объединение и "причёсывание" всего, что мы делали до, чтобы данные из базы данных появлялись на главной странице, а изображения добавлялись от пользователя.

Сначала по заданию 8:

Мы работали в админке - части сайта, куда есть доступ только особенным пользователям - админам. Админы имеют такие разрешения к редактированию и просмотру, которых нет у обычных пользователей. Пользователь-админ создаётся так:
python manage.py createsuperuser
Вас попросят ввести имя пользователя - это нужно сделать, на латинице. Выберите любое, но лучше что-то осмысленное типа admin. Затем попросят ввести email, тут можно просто нажать "enter". Затем дважды нужно ввести придуманный пароль. Аккуратно, курсор не будет двигаться, пока вы печатаете, это нормальная ситуация, просто после написания парола нажмите "enter". 

После создания пользователя запускаем сервер в помощью python manage.py runserver и переходим по ссылке http://127.0.0.1:8000/admin/
Попадаем на страницу авторизации, вводим данные, которые только что придумали. Теперь оказываемся внутри админки.

Чтобы внутри админки появилась наша таблица с данными, её необходимо наделить свойствами админской модели, а не обычной. Переходим в файл admin.py и вписываем туда код:
from django.contrib import admin
from .models import Advertisements14

class Advertisements14Admin(admin.ModelAdmin):
    pass #этот код нужен как заглушка, так как пока нет никаких доп свойств нашей таблицы, кроме того, что она видна в админке и может ею изменяться
admin.site.register(Advertisements14, Advertisements14Admin) # здесь мы говорим "пусть содержимое будет от таблицы Advertisements14, а доп функционал - от класса Advertisements14Admin

Таблица появилась в админке, но она пока выглядит плохо. Добавим элементы в код, чтобы улучшить визуал и производительность. Около элементов будет подписано, для чего они нужны:
from django.contrib import admin
from .models import Advertisements14

class Advertisements14Admin(admin.ModelAdmin):
    list_display = ['id', 'title', 'description', 'price', 'auction', 'connection', 'created_date'] # отвечает за то, какие толбцы таблицы будут показаны в админке
    list_filter = ['auction', 'created_time'] # задает поля для фильтрации (можем выбрать их из столбцов таблицы) - они будут справа на сайте
    actions = ['make_auction_as_false', 'make_auction_as_true'] # задает список функций, которые будут реализованы в выпадающем списке для выделенных строк таблицы
    fieldsets = (
        ('Общее', {
            'fields': ('title', 'description', 'connection'),
        }),
        ('Финансы', {
            'fields': ('price', 'auction'),
            'classes': ['collapse']
        })
    ) # задает разбиение поля заполнения объявления на смысловые блоки

    @admin.action(description='Убрать возможность торга') # а это и следующее - функции для actions, прописываются ниже остального кода
    def make_auction_as_false(self, request, queryset):
        queryset.update(auction=False)

    @admin.action(description='Добавить возможность торга')
    def make_auction_as_true(self, request, queryset):
        queryset.update(auction=True)

admin.site.register(Advertisements14, Advertisements14Admin) # здесь мы говорим "пусть содержимое будет от таблицы Advertisements14, а доп функционал - от класса Advertisements14Admin

Заполняйте данные элементы визуала админки последовательно, один за другим. После каждого обновляйте страницу и смотрите, как изменился сайт. Так вам будет проще отследить возможные неполадки и понимать, где именно они появились.

Последнее, что мы сделали на занятии, было изменение визуала отображения времени создания. Мы перешли в файл models.py и добавили после перечисления всех переменных (столбцов) код для функции изменения визуала времени создания объявления:
@admin.display(description='дата создания')
    def created_date(self):
        from django.utils import timezone
        if self.created_time.date() == timezone.now().date(): # если дата создания объявления - сегодняшняя дата, тогда
            created_time_2 = self.created_time.time().strftime("%H:%M:%S") # достать непосредственно время (часы, минуты, секунды)
            return format_html(
                '<span style="color: green; font-weight: bold;">Сегодня в {}</span>', created_time_2 # и положить его в html код в таком формате
            )
        return self.created_time.strftime("%d.%m.%Y в %H:%M:%S") # если не сегодня - просто остать дату  время, но в понятном нам формате
После написания такого кода нужно вернуться в admin.py и заменить в отображаемых столбцах created_time на created_date.

В домашке просили сделать то же самое со временем обновления, сделайте по образу и подобию кода выше, но вместо времени создания возьмите время последнего обновления.

Также в домашней просили иземнить название раздела на сайте на "Объявления". Делаем мы это, добавляя в конец файла apps.py строку verbose_name = 'Объявления'.

Теперь по занятию 9:

На этом занятии мы добавили информацию из базы данных на страницу html, которая показывается пользователю. Также добавили в шаблон информацию о пользователе и картинки.

Для начала:

Чтобы добавить информацию из таблицы в некоторую переменную advertisements, мы дополнили код файла views.py вот такими строками:
from .models import Advertisements14

def index(request):
    advertisements = Advertisements14.objects.all()
    context = {'advertisements':advertisements}
    return render(request, 'index.html', context)

Теперь содержимое таблицы лежит в advertisements и с помощью context передаётся вместе с html страницей в качестве параметраю

Чтобы вместо рукописного текста в html файле в браузере появились строки из БД, необходимо сделать следующее:
открыть index.html, найти все повторяющиеся блоки объявлений, начинающиеся с <div class="card mb-2"... и оставить из всех таких элементов только один. Теперь найдём элемент <div class="col"> и над ним пропишем {% for adv in advertisements %}, чтобы строки таблице заполняли шаблон одна за другой в цикле. В конце этого <div class="col"> после закрывающего </div> пропишем {% endfor %} для завершения цикла. Теперь заменим жесткий текст на содержимое строк и столбцов таблицы. Заголовок заменим на {{ adv.title }}, описание - на {{ adv.description }}, время создания - на {{ adv.created_time }}, а после времени создания допишем <span>Цена: {{ adv.price }}</span>.

Теперь, если взглянуть на главную страницу веб-приложения, рандомный текст заменится на содержимое нашей таблицы с объявлениями.

Однако, информации о пользователе и картинок всё ещё не хватает. Сначала пользователь:

В файле models.py импортируем функцию from django.contrib.auth import get_user_model, затем с помощью этой функции создаём класс-таблицу User = get_user_model(). В конец перечисления столбцов таблицы добавляем user = models.ForeignKey(User, verbose_name='пользователь',on_delete=models.CASCADE)
В данном случае выбрали CASCADE, а не PROTECT, так как первый удаляет все объявления удаленного пользователя, а второй не дает удалить пользователя, если у него есть хотя бы одно объявление.
После внесения изменений в таблицу нужна миграция:
python manage.py makemigrations
Нас попросят указать значение по умолчанию - выбираем 1, и в качестве значения по умолчанию тоже вводим 1. Так для нашего пользователя admin индекс станет 1, а другим пользователям уже будет присваиваться по возрастанию.

Теперь проводим python manage.py migrate

После проведения миграции идём в index.html и на место имени автора вписываем {{ adv.user }}

С пользователем разобрались, теперь изображения:

В models.py добавляем очередной столбец image = models.ImageField('изображение', upload_to='advertisements/')
Чтобы было, куда складывать картинки от пользователя, создадим папку media на уровне остальных приложений, шаблонов и статики. 
В файле settings.py пропишем путь до этого места MEDIA_ROOT = Path.joinpath(BASE_DIR, 'media/').
Сделаем миграцию python manage.py makemigrations и заполним значение по умолчанию на один раз - нажмём 1, а потом введём '' - пустые кавычки, ничего.

Если миграция с первого раза не прошла, а пожаловалась на отсутствие библиотеки Pillow, тогда качаем её с помощью python -m pip install Pillow. Если прошла, то ничего не инсталлим. Дальше сама миграция - python manage.py migrate
Чтобы графа изображений показалась в админке, в файле admin.py добавляем столбец 'image' в list_display и в fields в графе 'Общее'.

Далее, чтобы картинка открывалась по ссылке, делаем так:
в файле settings.py дописываем MEDIA_URL = 'media/', затем в файле urls.py папки advertisements14 импортируем 
from django.conf import settings
from django.conf.urls.static import static
и добавляем внизу всего кода 
if settings.DEBUG:
    urlpatterns +=static(settings.MEDIA_URL,document_root=settings.MEDIA_ROOT)

Теперь картинка будет открываться. Чтобы добавить её на сайт, меняем содержимое тега img в шаблоне index.html на <img src="{% if adv.image %} {{adv.image.url }} {% endif %}">

Наслаждаемся результатом.

Здесь представлен алгоритм действий. Для понимания темы и того, что одначает каждое действие и почему оно проводится, стоит открыть запись занятия и просмотреть. Удачи в освоении!
